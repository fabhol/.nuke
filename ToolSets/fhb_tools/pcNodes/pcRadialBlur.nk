Group {
 name pcRadialBlur
 tile_color 0x7f7f7fff
 addUserKnob {20 RadialBlurTab l RadialBlur}
 addUserKnob {4 output l mode t "Choose the layers that you want to affect.\n\nRGB: Only affects the RGB layer\n\nRGB + pc_alpha: Affects RGB and the per channel alpha layer. Select this mode, if you want to merge the result over a background.\n\npc_alpha: Only affect the per channel alpha layer. Select this mode if your RGB channels already have chromatic aberration (for example objects from the plate), and you want to merge them on top of a background.\nIn this case the RGB layer should not be premultiplied yet. Tick the 'premult RGB' check box in the pcMerge instead." M {RGB "RGB + pc_alpha" pc_alpha ""}}
 addUserKnob {41 alpha_operation l " alpha" t "There is no way of retaining a correct alpha channel after seperately processing the RGB channels. This lets you generate a new alpha based on the pc_alpha layer.\n\n<b>original</b>: the original alpha is piped through\n<b>average</b>/<b>max</b>/<b>min</b>: average/max/min of the three pc_alpha channels\n<b>luminance</b>: luminance of the pc_alpha using the Rec. 709 luma coefficients" -STARTLINE T GenerateAlpha.operation}
 addUserKnob {22 link_center l "link to center" +HIDDEN T "node = nuke.thisNode()\nnode\['center'].setExpression('width/2+.5',0)\nnode\['center'].setExpression('height/2+.5',1)\nnode\['link_center'].setVisible(False)\nnode\['release_center'].setVisible(True)" +STARTLINE}
 addUserKnob {6 show_vectors l "show vectors" +STARTLINE}
 addUserKnob {3 res -STARTLINE}
 res 20
 addUserKnob {26 divider01 l " "}
 addUserKnob {18 scale R 0 10}
 scale {0 0 0}
 addUserKnob {18 offset R -0.5 0.5}
 offset {0 0 0}
 addUserKnob {7 ar l AR R 0 10}
 ar 1
 addUserKnob {22 set_to_format l "set to format" -STARTLINE T "node = nuke.thisNode()\nnode\['ar'].setExpression('width/height*pixel_aspect')"}
 addUserKnob {7 weighting R 0 5}
 weighting 1
 addUserKnob {20 curve_group l curve n 1}
 curve_group 0
 addUserKnob {6 curve l "use curve for weighting (slower but more flexible)" +STARTLINE}
 addUserKnob {41 lut l "" +STARTLINE T TimeDissolve1.lut}
 addUserKnob {20 endGroup n -1}
 addUserKnob {14 multiply R 0 100}
 multiply 1
 addUserKnob {12 center}
 center {{width/2+.5} {height/2+.5}}
 addUserKnob {22 release_center l "release center" -STARTLINE T "node = nuke.thisNode()\nnode\['center'].clearAnimated()\nnode\['release_center'].setVisible(False)\nnode\['link_center'].setVisible(True)"}
 addUserKnob {26 _1 l "" +STARTLINE}
 addUserKnob {41 from0 l "effect mask" T Copy3.from0}
 addUserKnob {6 invert_effect_mask l invert -STARTLINE}
 addUserKnob {26 "" l mask T ""}
 addUserKnob {41 maskChannelMask l "" -STARTLINE T Dissolve1.maskChannelMask}
 addUserKnob {41 inject -STARTLINE T Dissolve1.inject}
 addUserKnob {41 invert_mask l invert -STARTLINE T Dissolve1.invert_mask}
 addUserKnob {41 fringe -STARTLINE T Dissolve1.fringe}
 addUserKnob {41 mix T Dissolve1.which}
 addUserKnob {20 Info_tab l Info}
 addUserKnob {26 dasname l "" +STARTLINE T "per channel<br><font size='5'>RadialBlur</font> v1.02<br>"}
 addUserKnob {26 what l "" +STARTLINE T "pcRadialBlur is part of the pc toolset, a collection of nodes that offer\nthe possibility to affect the channels seperately. Chain them up in any\nway to achieve the desired effect.\n\nAn optional per channel alpha layer (pc_alpha) can be created to cor-\nrectly merge the result over a background. In this case it's necessary\nto use the pcMerge instead of a regular Merge."}
 addUserKnob {26 divider l "" +STARTLINE}
 addUserKnob {26 info l "" +STARTLINE T "Last change: 2019-09-09\n"}
 addUserKnob {26 name_1 l "" +STARTLINE T "\nFabian Holtz"}
 addUserKnob {26 mail l "" +STARTLINE T "<a href=\"mailto:holtzf+nuke@gmail.com\"><span style=\"color:#C8C8C8;\">holtzf+nuke@gmail.com</a>"}
}
 Input {
  inputs 0
  name mask
  xpos -1800
  ypos 969
  number 1
 }
 Dot {
  name Dot1
  xpos -1766
  ypos 1050
 }
 Input {
  inputs 0
  name effect_mask
  xpos -590
  ypos 57
  number 2
 }
 Dot {
  name Dot14
  xpos -556
  ypos 114
 }
set N30f3d370 [stack 0]
push $N30f3d370
 Copy {
  inputs 2
  to0 rgba.red
  from1 {{{from0}}}
  to1 rgba.green
  name Copy3
  xpos -590
  ypos 147
 }
 Invert {
  channels {rgba.red rgba.green -rgba.blue none}
  name Invert1
  xpos -590
  ypos 230
  disable {{!parent.invert_effect_mask}}
 }
 Dot {
  name Dot13
  xpos -556
  ypos 282
 }
 Input {
  inputs 0
  name Input
  xpos -1580
  ypos -567
 }
 Dot {
  name Dot3
  xpos -1546
  ypos -462
 }
set N3601e2a0 [stack 0]
 Dot {
  name Dot17
  xpos -1106
  ypos -462
 }
set N2f7b10e0 [stack 0]
 Dot {
  name Dot16
  xpos -996
  ypos -462
 }
 Expression {
  temp_name0 resx
  temp_expr0 width/res
  temp_name1 resy
  temp_expr1 height/ceil(res/width*height/pixel_aspect)
  channel0 none
  channel1 none
  channel2 none
  expr3 (1-clamp(floor((x+resx/2)%resx)))*(1-clamp(floor((y+resy/2)%resy)))*300
  name Expression5
  xpos -1030
  ypos -420
  addUserKnob {20 User}
  addUserKnob {3 res}
  res {{max(parent.res,1)}}
 }
 Shuffle {
  red alpha
  green alpha
  blue alpha
  name Shuffle4
  xpos -1030
  ypos -370
 }
 Dot {
  name Dot15
  xpos -996
  ypos -318
 }
push $N2f7b10e0
 Merge2 {
  inputs 2
  name Merge2
  xpos -1140
  ypos -322
  disable {{!parent.show_vectors}}
 }
add_layer {pc_alpha pc_alpha.red pc_alpha.green pc_alpha.blue}
 Shuffle {
  red alpha
  green alpha
  blue alpha
  out pc_alpha
  name Shuffle1
  xpos -1140
  ypos -178
  disable {{"\[string first \"pc_alpha\" \[layers \[input this 0]]]>-1"}}
 }
 Remove {
  operation keep
  channels rgb
  channels2 pc_alpha
  name Remove1
  xpos -1140
  ypos -93
 }
 Dot {
  name Dot5
  xpos -1106
  ypos -6
 }
set N15794cb0 [stack 0]
 Dot {
  name Dot11
  xpos -886
  ypos -6
 }
 Expression {
  temp_name0 center
  temp_expr0 parent.center
  expr0 (y-center.y)*width/2048
  expr1 -(x-center.x)*pixel_aspect/parent.ar*width/2048
  expr2 hypot((x-center.x),(y-center.y)/pixel_aspect/parent.ar)
  expr3 abs(1-abs(atan(x-center.x,(y-center.y)/pixel_aspect/parent.ar)/pi)*2)
  name Expression2
  xpos -920
  ypos 38
 }
set N211e4210 [stack 0]
 Expression {
  temp_name0 n
  temp_expr0 hypot(width/2,height/2/pixel_aspect)
  expr0 r/b*TimeDissolve1.lut(b/n)
  expr1 g/b*TimeDissolve1.lut(b/n)
  expr2 1-lerp(1-a,0,parent.multiply.w)-lerp(a,0,parent.multiply.h)
  name Expression3
  xpos -810
  ypos 110
 }
push $N211e4210
 Expression {
  temp_name0 n
  temp_expr0 hypot(width/2,height/2/pixel_aspect/parent.ar)
  temp_name1 p
  temp_expr1 1/parent.weighting
  expr0 r/b*pow(b/n,p)
  expr1 g/b*pow(b/n,p)
  expr2 1-lerp(a,0,parent.multiply.w)-lerp(1-a,0,parent.multiply.h)
  name Expression4
  xpos -1030
  ypos 110
 }
 Switch {
  inputs 2
  which {{parent.curve}}
  name Switch1
  xpos -920
  ypos 182
 }
 Expression {
  expr0 r*b
  expr1 g*b
  name Expression1
  xpos -920
  ypos 230
 }
 Merge2 {
  inputs 2
  operation multiply
  Achannels {rgba.red rgba.green -rgba.blue none}
  Bchannels {rgba.red rgba.green -rgba.blue none}
  output {rgba.red rgba.green -rgba.blue none}
  name Merge1
  xpos -920
  ypos 278
  disable {{"!\[exists parent.input2.name] || Copy3.from0==0"}}
 }
 Dot {
  name Dot12
  xpos -886
  ypos 378
 }
push $N15794cb0
 Copy {
  inputs 2
  from0 rgba.red
  to0 forward.u
  from1 rgba.green
  to1 forward.v
  name Copy4
  xpos -1140
  ypos 363
 }
 VectorBlur {
  channels {rgba.red -rgba.green -rgba.blue pc_alpha.red}
  uv forward
  scale {{parent.scale.r}}
  offset {{-.5-parent.offset.r}}
  name VectorBlur1
  xpos -1140
  ypos 513
 }
 VectorBlur {
  channels {-rgba.red rgba.green -rgba.blue pc_alpha.green}
  uv forward
  scale {{parent.scale.g}}
  offset {{-.5-parent.offset.g}}
  name VectorBlur2
  xpos -1140
  ypos 561
 }
 VectorBlur {
  channels {-rgba.red -rgba.green rgba.blue pc_alpha.blue}
  uv forward
  scale {{parent.scale.b}}
  offset {{-.5-parent.offset.b}}
  name VectorBlur3
  xpos -1140
  ypos 609
 }
 Dot {
  name Dot9
  xpos -1106
  ypos 786
 }
set N40125110 [stack 0]
 Dot {
  name Dot8
  xpos -1106
  ypos 882
 }
set N2626f6e0 [stack 0]
 Group {
  name GenerateAlpha
  tile_color 0x7f7f7fff
  selected true
  xpos -1140
  ypos 974
  addUserKnob {20 GenerateAlpha_tab l GenerateAlpha}
  addUserKnob {4 operation M {original average luminance max min "" "" "" ""}}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos 14
  }
  Dot {
   name Dot1
   xpos -6
   ypos 114
  }
set N39e3b0f0 [stack 0]
  Expression {
   expr3 min(pc_alpha.red,pc_alpha.green,pc_alpha.blue)
   name min
   xpos 180
   ypos 206
  }
push $N39e3b0f0
  Expression {
   expr3 max(pc_alpha.red,pc_alpha.green,pc_alpha.blue)
   name max
   xpos 70
   ypos 206
  }
push $N39e3b0f0
  Expression {
   expr3 pc_alpha.red*0.2126+pc_alpha.green*0.7152+pc_alpha.blue*0.0722
   name luminance
   xpos -40
   ypos 206
  }
push $N39e3b0f0
  Expression {
   expr3 (pc_alpha.red+pc_alpha.green+pc_alpha.blue)/3
   name average
   xpos -150
   ypos 206
  }
push $N39e3b0f0
  Dot {
   name Dot2
   xpos -226
   ypos 210
  }
  Switch {
   inputs 5
   which {{parent.operation}}
   name Switch1
   xpos -40
   ypos 302
  }
  Output {
   name Output1
   xpos -40
   ypos 398
  }
 end_group
push $N2626f6e0
push $N40125110
push $N15794cb0
push $N3601e2a0
 Copy {
  inputs 2
  channels pc_alpha
  name Copy10
  xpos -1580
  ypos -21
  disable {{"parent.output==0 || Dissolve1.which<=0"}}
 }
 Dot {
  name Dot6
  xpos -1546
  ypos 690
 }
set N153ad180 [stack 0]
 Dot {
  name Dot7
  xpos -1326
  ypos 690
 }
 Copy {
  inputs 2
  channels rgb
  name Copy1
  xpos -1360
  ypos 771
  disable {{parent.output==2}}
 }
 Copy {
  inputs 2
  channels pc_alpha
  name Copy6
  xpos -1360
  ypos 867
  disable {{parent.output==0}}
 }
 Copy {
  inputs 2
  from0 rgba.alpha
  to0 rgba.alpha
  name Copy11
  selected true
  xpos -1360
  ypos 969
  disable {{GenerateAlpha.operation==0}}
 }
 Dot {
  name Dot10
  xpos -1326
  ypos 1050
 }
push $N153ad180
 Dissolve {
  inputs 2+1
  which 1
  maskChannelMask none
  name Dissolve1
  xpos -1580
  ypos 1041
  disable {{"(!\[exists parent.input0.name]) && (Merge2.disable)"}}
 }
 Output {
  name Output1
  xpos -1580
  ypos 1166
 }
 TimeDissolve {
  inputs 0
  lut {curve {curve L 0 s0 l 1 s2.799999952}}
  name TimeDissolve1
  xpos -810
  ypos 38
 }
end_group
